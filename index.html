<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TW2 Incoming Attack Parser</title>
  <style>
    * {
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      min-height: 100vh;
      margin: 0;
      padding: 20px;
      color: #e0e0e0;
    }
    
    .container {
      max-width: 1400px;
      margin: 0 auto;
    }
    
    h1 {
      text-align: center;
      color: #ff6b6b;
      margin-bottom: 10px;
      text-shadow: 0 0 20px rgba(255, 107, 107, 0.3);
    }
    
    .subtitle {
      text-align: center;
      color: #888;
      margin-bottom: 30px;
    }
    
    .input-section {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 30px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .input-section label {
      display: block;
      margin-bottom: 10px;
      color: #aaa;
      font-size: 14px;
    }
    
    textarea {
      width: 100%;
      height: 150px;
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      padding: 15px;
      color: #e0e0e0;
      font-family: 'Consolas', 'Monaco', monospace;
      font-size: 12px;
      resize: vertical;
    }
    
    textarea:focus {
      outline: none;
      border-color: #ff6b6b;
      box-shadow: 0 0 10px rgba(255, 107, 107, 0.2);
    }
    
    .btn-row {
      display: flex;
      gap: 10px;
      margin-top: 15px;
    }
    
    button {
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .btn-parse {
      background: linear-gradient(135deg, #ff6b6b, #ee5a5a);
      color: white;
    }
    
    .btn-parse:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(255, 107, 107, 0.4);
    }
    
    .btn-clear {
      background: rgba(255, 255, 255, 0.1);
      color: #aaa;
    }
    
    .btn-clear:hover {
      background: rgba(255, 255, 255, 0.2);
    }
    
    .results-section {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      padding: 20px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .results-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    
    .results-header h2 {
      margin: 0;
      color: #4ecdc4;
    }
    
    .attack-count {
      background: rgba(78, 205, 196, 0.2);
      color: #4ecdc4;
      padding: 8px 16px;
      border-radius: 20px;
      font-weight: 600;
    }
    
    .table-wrapper {
      overflow-x: auto;
    }
    
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
    }
    
    th {
      background: rgba(255, 107, 107, 0.2);
      color: #ff6b6b;
      padding: 14px 12px;
      text-align: left;
      font-weight: 600;
      white-space: nowrap;
      border-bottom: 2px solid rgba(255, 107, 107, 0.3);
    }
    
    td {
      padding: 12px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }
    
    tr:hover td {
      background: rgba(255, 255, 255, 0.03);
    }
    
    .village-name {
      font-weight: 500;
      color: #fff;
    }
    
    .coords {
      color: #888;
      font-family: 'Consolas', monospace;
      font-size: 13px;
    }
    
    .arrival-time {
      color: #feca57;
      font-weight: 500;
    }
    
    .sent-time {
      color: #a29bfe;
      font-weight: 500;
    }
    
    .time-remaining {
      color: #ff6b6b;
      font-family: 'Consolas', monospace;
      font-weight: 600;
    }
    
    .progress-cell {
      min-width: 120px;
    }
    
    .progress-bar-container {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 10px;
      height: 20px;
      overflow: hidden;
      position: relative;
    }
    
    .progress-bar-fill {
      height: 100%;
      border-radius: 10px;
      transition: width 0.3s;
    }
    
    .progress-low { background: linear-gradient(90deg, #27ae60, #2ecc71); }
    .progress-mid { background: linear-gradient(90deg, #f39c12, #f1c40f); }
    .progress-high { background: linear-gradient(90deg, #e74c3c, #c0392b); }
    
    .progress-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 11px;
      font-weight: 600;
      color: white;
      text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    }
    
    .no-results {
      text-align: center;
      padding: 60px 20px;
      color: #666;
    }
    
    .no-results-icon {
      font-size: 48px;
      margin-bottom: 15px;
    }
    
    .player-name {
      color: #a29bfe;
      font-size: 12px;
    }
    
    .distance {
      font-family: 'Consolas', monospace;
      color: #74b9ff;
      font-weight: 500;
    }
    
    .unit-type {
      white-space: nowrap;
    }
    
    .unit-badge {
      display: inline-block;
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 700;
      color: white;
      text-shadow: 0 1px 2px rgba(0,0,0,0.3);
    }
    
    .unit-confidence {
      display: inline-block;
      margin-left: 6px;
      font-size: 11px;
      color: #888;
      cursor: help;
    }

    .sort-btn {
      cursor: pointer;
      user-select: none;
    }
    
    .sort-btn:hover {
      color: #fff;
    }
    
    .sort-btn::after {
      content: ' ‚Üï';
      opacity: 0.5;
    }
    
    .toast {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%) translateY(100px);
      background: linear-gradient(135deg, #4ecdc4, #44a08d);
      color: white;
      padding: 14px 28px;
      border-radius: 30px;
      font-weight: 600;
      box-shadow: 0 5px 20px rgba(78, 205, 196, 0.4);
      opacity: 0;
      transition: all 0.3s ease;
      z-index: 1000;
    }
    
    .toast.show {
      transform: translateX(-50%) translateY(0);
      opacity: 1;
    }
    
    .stats-row {
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
    }
    
    .stat-badge {
      background: rgba(255, 255, 255, 0.1);
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 13px;
    }
    
    .stat-badge span {
      color: #4ecdc4;
      font-weight: 600;
    }

    .village-name-clickable {
      cursor: pointer;
      transition: all 0.2s;
      border-radius: 4px;
      padding: 2px 4px;
      margin: -2px -4px;
    }

    .village-name-clickable:hover {
      background: rgba(78, 205, 196, 0.2);
      color: #4ecdc4;
    }

    .filter-indicator {
      display: none;
      align-items: center;
      gap: 10px;
      background: rgba(78, 205, 196, 0.15);
      border: 1px solid rgba(78, 205, 196, 0.3);
      padding: 10px 16px;
      border-radius: 8px;
      margin-bottom: 15px;
    }

    .filter-indicator.active {
      display: flex;
    }

    .filter-indicator-text {
      color: #4ecdc4;
      font-size: 14px;
    }

    .filter-indicator-text strong {
      color: #fff;
    }

    .filter-clear-btn {
      background: rgba(255, 107, 107, 0.2);
      color: #ff6b6b;
      border: 1px solid rgba(255, 107, 107, 0.3);
      padding: 5px 12px;
      border-radius: 15px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }

    .filter-clear-btn:hover {
      background: rgba(255, 107, 107, 0.4);
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>‚öîÔ∏è TW2 Incoming Attack Parser</h1>
    <p class="subtitle">Paste the HTML from your incoming attacks page to parse and display them</p>
    
    <div class="input-section">
      <label>Paste HTML source here (entire page or just the table):</label>
      <textarea id="htmlInput" placeholder="<table class=&quot;tbl-border-light..."></textarea>
      <div class="btn-row">
        <button class="btn-parse" onclick="parseAttacks()">üîç Parse Attacks</button>
        <button class="btn-clear" onclick="clearAll()">Clear</button>
      </div>
    </div>
    
    <div class="results-section">
      <div class="results-header">
        <h2>üìã Parsed Attacks</h2>
        <div class="stats-row">
          <div class="attack-count" id="attackCount">0 attacks</div>
        </div>
      </div>
      
      <div id="filterIndicator" class="filter-indicator">
        <span class="filter-indicator-text">
          Filtering by <span id="filterType"></span>: <strong id="filterValue"></strong>
        </span>
        <button class="filter-clear-btn" onclick="clearFilter()">Clear Filter</button>
      </div>

      <div class="table-wrapper">
        <table id="resultsTable">
          <thead>
            <tr>
              <th>#</th>
              <th class="sort-btn" onclick="sortTable('origin')">Origin Village</th>
              <th>Origin Coords</th>
              <th class="sort-btn" onclick="sortTable('target')">Target Village</th>
              <th>Target Coords</th>
              <th class="sort-btn" onclick="sortTable('arrival')">Arrival Time</th>
              <th class="sort-btn" onclick="sortTable('sent')">Sent Time</th>
              <th class="sort-btn" onclick="sortTable('remaining')">Time Remaining</th>
              <th class="sort-btn" onclick="sortTable('progress')">Progress</th>
              <th class="sort-btn" onclick="sortTable('distance')">Distance</th>
              <th class="sort-btn" onclick="sortTable('unit')">Unit Type</th>
            </tr>
          </thead>
          <tbody id="resultsBody">
            <tr>
              <td colspan="11" class="no-results">
                <div class="no-results-icon">üì≠</div>
                <div>No attacks parsed yet. Paste HTML above and click "Parse Attacks"</div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <script>
    let parsedData = [];
    let currentFilter = null; // { type: 'origin'|'target', villageName: string }

    function setFilter(type, villageName) {
      currentFilter = { type, villageName };
      updateFilterIndicator();
      renderTable(parsedData);
    }

    function clearFilter() {
      currentFilter = null;
      updateFilterIndicator();
      renderTable(parsedData);
    }

    function updateFilterIndicator() {
      const indicator = document.getElementById('filterIndicator');
      const filterType = document.getElementById('filterType');
      const filterValue = document.getElementById('filterValue');

      if (currentFilter) {
        indicator.classList.add('active');
        filterType.textContent = currentFilter.type === 'origin' ? 'Origin Village' : 'Target Village';
        filterValue.textContent = currentFilter.villageName;
      } else {
        indicator.classList.remove('active');
      }
    }

    function getFilteredData(data) {
      if (!currentFilter) return data;

      return data.filter(attack => {
        if (currentFilter.type === 'origin') {
          return attack.origin.name === currentFilter.villageName;
        } else {
          return attack.target.name === currentFilter.villageName;
        }
      });
    }

    // Unit speeds in minutes per 1 distance
    const UNIT_SPEEDS = [
      { name: 'LC', speed: 8, color: '#00cec9' },
      { name: 'HC', speed: 9, color: '#6c5ce7' },
      { name: 'Axe', speed: 14, color: '#e17055' },
      { name: 'Sword', speed: 18, color: '#fdcb6e' },
      { name: 'Ram', speed: 24, color: '#d63031' },
      { name: 'Nobles', speed: 35, color: '#e84393' },
      { name: 'Trebs', speed: 50, color: '#2d3436' }
    ];
    
    function calculateDistance(x1, y1, x2, y2) {
      const xx1 = x1 - ((y1 % 2 === 0) ? 0.5 : 0);
      const yy1 = y1;
      const xx2 = x2 - ((y2 % 2 === 0) ? 0.5 : 0);
      const yy2 = y2;
      return Math.sqrt(Math.pow(xx1 - xx2, 2) + 0.75 * Math.pow(yy1 - yy2, 2));
    }
    
    function parseTimeRemaining(timeStr) {
      // Parse "H:MM:SS" or "M:SS" format to total seconds
      const parts = timeStr.split(':').map(Number);
      if (parts.length === 3) {
        return parts[0] * 3600 + parts[1] * 60 + parts[2];
      } else if (parts.length === 2) {
        return parts[0] * 60 + parts[1];
      }
      return 0;
    }
    
    function calculateSentTime(arrivalTimeStr, distance, unitType) {
      if (!arrivalTimeStr || !distance || !unitType) return null;
      
      // Total travel time = distance * unit speed (in minutes), convert to seconds
      const totalTravelTimeSeconds = distance * unitType.unit.speed * 60;
      
      // Parse arrival time - handle "Today at H:MM:SS AM/PM" or similar formats
      const timeMatch = arrivalTimeStr.match(/(\d{1,2}):(\d{2}):(\d{2})\s*(AM|PM)?/i);
      if (!timeMatch) return null;
      
      let hours = parseInt(timeMatch[1]);
      const minutes = parseInt(timeMatch[2]);
      const seconds = parseInt(timeMatch[3]);
      const ampm = timeMatch[4];
      
      // Convert to 24h format if AM/PM present
      if (ampm) {
        if (ampm.toUpperCase() === 'PM' && hours !== 12) hours += 12;
        if (ampm.toUpperCase() === 'AM' && hours === 12) hours = 0;
      }
      
      // Create arrival date (use today's date as base)
      const arrival = new Date();
      arrival.setHours(hours, minutes, seconds, 0);
      
      // Handle "Tomorrow" in arrival string
      if (arrivalTimeStr.toLowerCase().includes('tomorrow')) {
        arrival.setDate(arrival.getDate() + 1);
      }
      
      // Calculate sent time by subtracting total travel time
      const sentTime = new Date(arrival.getTime() - totalTravelTimeSeconds * 1000);
      
      // Format sent time
      const sentHours = sentTime.getHours();
      const sentMinutes = sentTime.getMinutes().toString().padStart(2, '0');
      const sentSeconds = sentTime.getSeconds().toString().padStart(2, '0');
      
      // Determine if it's today or yesterday
      const now = new Date();
      const isToday = sentTime.toDateString() === now.toDateString();
      const yesterday = new Date(now);
      yesterday.setDate(yesterday.getDate() - 1);
      const isYesterday = sentTime.toDateString() === yesterday.toDateString();
      
      let dayPrefix = '';
      if (isToday) dayPrefix = 'Today at ';
      else if (isYesterday) dayPrefix = 'Yesterday at ';
      else dayPrefix = sentTime.toLocaleDateString() + ' ';
      
      // Format in 12h with AM/PM
      const displayHours = sentHours % 12 || 12;
      const displayAmPm = sentHours >= 12 ? 'PM' : 'AM';
      
      return `${dayPrefix}${displayHours}:${sentMinutes}:${sentSeconds} ${displayAmPm}`;
    }
    
    function detectUnitType(distance, percentComplete, timeRemainingStr) {
      if (!distance || distance === 0 || percentComplete === 0) return null;
      
      const timeRemainingSeconds = parseTimeRemaining(timeRemainingStr);
      
      // Total travel time = timeRemaining / (1 - percentComplete/100)
      // Because: timeRemaining = totalTime * (1 - percentComplete/100)
      const totalTravelTimeSeconds = timeRemainingSeconds / (1 - percentComplete / 100);
      const totalTravelTimeMinutes = totalTravelTimeSeconds / 60;
      
      // Calculate actual speed (minutes per distance)
      const actualSpeed = totalTravelTimeMinutes / distance;
      
      // Find the closest matching unit
      let bestMatch = null;
      let smallestDiff = Infinity;
      
      for (const unit of UNIT_SPEEDS) {
        const diff = Math.abs(unit.speed - actualSpeed);
        if (diff < smallestDiff) {
          smallestDiff = diff;
          bestMatch = unit;
        }
      }
      
      // Calculate confidence (how close the match is)
      const confidence = Math.max(0, 100 - (smallestDiff / bestMatch.speed * 100));
      
      return {
        unit: bestMatch,
        actualSpeed: actualSpeed,
        confidence: confidence
      };
    }
    
    function parseIncomingAttacks(html) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, 'text/html');
      const rows = doc.querySelectorAll('tr[ng-repeat="command in commands"]');
      
      return Array.from(rows).map(row => {
        const coordsRegex = /\((\d+)\s*\|\s*(\d+)\)/;
        
        const targetCoordsText = row.querySelector('td.column-target_village_name .coordinates')?.textContent || '';
        const originCoordsText = row.querySelector('td.column-origin_village_name .coordinates')?.textContent || '';
        const targetMatch = targetCoordsText.match(coordsRegex);
        const originMatch = originCoordsText.match(coordsRegex);
        
        const progressBar = row.querySelector('td.column-command_progress .progress-bar');
        const widthStyle = progressBar?.getAttribute('style') || '';
        const percentMatch = widthStyle.match(/width:\s*(\d+)%/);
        
        const playerName = row.querySelector('td.column-origin_character_name .character')?.textContent?.trim() || '';
        
        // Calculate distance between origin and target
        const distance = (originMatch && targetMatch) 
          ? calculateDistance(
              parseInt(originMatch[1]), parseInt(originMatch[2]),
              parseInt(targetMatch[1]), parseInt(targetMatch[2])
            )
          : null;
        
        const timeRemaining = row.querySelector('td.column-command_progress .progress-text span')?.textContent?.trim() || '';
        const percentComplete = percentMatch ? parseInt(percentMatch[1]) : 0;
        const arrivalTime = row.querySelector('td.column-time_completed div')?.textContent?.trim() || '';
        const unitType = detectUnitType(distance, percentComplete, timeRemaining);
        
        return {
          target: {
            name: row.querySelector('td.column-target_village_name .name')?.textContent?.trim() || '',
            x: targetMatch ? parseInt(targetMatch[1]) : null,
            y: targetMatch ? parseInt(targetMatch[2]) : null
          },
          origin: {
            name: row.querySelector('td.column-origin_village_name .name')?.textContent?.trim() || '',
            x: originMatch ? parseInt(originMatch[1]) : null,
            y: originMatch ? parseInt(originMatch[2]) : null,
            player: playerName
          },
          arrivalTime: arrivalTime,
          sentTime: calculateSentTime(arrivalTime, distance, unitType),
          percentComplete: percentComplete,
          timeRemaining: timeRemaining,
          distance: distance,
          unitType: unitType
        };
      });
    }
    
    function getProgressClass(percent) {
      if (percent < 40) return 'progress-low';
      if (percent < 70) return 'progress-mid';
      return 'progress-high';
    }
    
    function renderTable(data) {
      const tbody = document.getElementById('resultsBody');
      const countEl = document.getElementById('attackCount');

      // Apply filter
      const filteredData = getFilteredData(data);

      if (data.length === 0) {
        tbody.innerHTML = `
          <tr>
            <td colspan="11" class="no-results">
              <div class="no-results-icon">üì≠</div>
              <div>No attacks found in the pasted HTML</div>
            </td>
          </tr>
        `;
        countEl.textContent = '0 attacks';
        return;
      }

      if (filteredData.length === 0 && currentFilter) {
        tbody.innerHTML = `
          <tr>
            <td colspan="11" class="no-results">
              <div class="no-results-icon">üîç</div>
              <div>No attacks match the current filter</div>
            </td>
          </tr>
        `;
        countEl.textContent = `0 of ${data.length} attacks`;
        return;
      }

      // Update count to show filtered vs total
      if (currentFilter) {
        countEl.textContent = `${filteredData.length} of ${data.length} attack${data.length !== 1 ? 's' : ''}`;
      } else {
        countEl.textContent = `${data.length} attack${data.length !== 1 ? 's' : ''}`;
      }

      tbody.innerHTML = filteredData.map((attack, idx) => `
        <tr>
          <td>${idx + 1}</td>
          <td>
            <div class="village-name village-name-clickable" title="Click to filter by this origin village" onclick="setFilter('origin', '${escapeHtml(attack.origin.name).replace(/'/g, "\\'")}')">${escapeHtml(attack.origin.name)}</div>
            <div class="player-name">${escapeHtml(attack.origin.player)}</div>
          </td>
          <td class="coords">(${attack.origin.x} | ${attack.origin.y})</td>
          <td>
            <div class="village-name village-name-clickable" title="Click to filter by this target village" onclick="setFilter('target', '${escapeHtml(attack.target.name).replace(/'/g, "\\'")}')">${escapeHtml(attack.target.name)}</div>
          </td>
          <td class="coords">(${attack.target.x} | ${attack.target.y})</td>
          <td class="arrival-time">${escapeHtml(attack.arrivalTime)}</td>
          <td class="sent-time">${attack.sentTime ? escapeHtml(attack.sentTime) : '-'}</td>
          <td class="time-remaining">${escapeHtml(attack.timeRemaining)}</td>
          <td class="progress-cell">
            <div class="progress-bar-container">
              <div class="progress-bar-fill ${getProgressClass(attack.percentComplete)}" style="width: ${attack.percentComplete}%"></div>
              <div class="progress-text">${attack.percentComplete}%</div>
            </div>
          </td>
          <td class="distance">${attack.distance !== null ? attack.distance.toFixed(2) : '-'}</td>
          <td class="unit-type">
            ${attack.unitType ? `
              <span class="unit-badge" style="background-color: ${attack.unitType.unit.color}">
                ${attack.unitType.unit.name}
              </span>
              <span class="unit-confidence" title="Calculated speed: ${attack.unitType.actualSpeed.toFixed(1)} min/field">${Math.round(attack.unitType.confidence)}%</span>
            ` : '-'}
          </td>
        </tr>
      `).join('');
    }
    
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
    
    function parseAttacks() {
      const html = document.getElementById('htmlInput').value;
      if (!html.trim()) {
        alert('Please paste some HTML first');
        return;
      }
      
      const newAttacks = parseIncomingAttacks(html);
      
      if (newAttacks.length === 0) {
        alert('No attacks found in the pasted HTML');
        return;
      }
      
      // Add new attacks to existing ones
      parsedData = [...parsedData, ...newAttacks];
      renderTable(parsedData);
      
      // Clear textarea for next paste
      document.getElementById('htmlInput').value = '';
      
      // Show feedback
      showToast(`Added ${newAttacks.length} attack${newAttacks.length !== 1 ? 's' : ''} (Total: ${parsedData.length})`);
    }
    
    function clearAll() {
      document.getElementById('htmlInput').value = '';
      parsedData = [];
      currentFilter = null;
      updateFilterIndicator();
      renderTable([]);
    }
    
    function timeToSeconds(timeStr) {
      const parts = timeStr.split(':').map(Number);
      if (parts.length === 3) {
        return parts[0] * 3600 + parts[1] * 60 + parts[2];
      } else if (parts.length === 2) {
        return parts[0] * 60 + parts[1];
      }
      return 0;
    }
    
    function parseArrivalToDate(arrivalTimeStr) {
      if (!arrivalTimeStr) return null;
      
      const timeMatch = arrivalTimeStr.match(/(\d{1,2}):(\d{2}):(\d{2})\s*(AM|PM)?/i);
      if (!timeMatch) return null;
      
      let hours = parseInt(timeMatch[1]);
      const minutes = parseInt(timeMatch[2]);
      const seconds = parseInt(timeMatch[3]);
      const ampm = timeMatch[4];
      
      if (ampm) {
        if (ampm.toUpperCase() === 'PM' && hours !== 12) hours += 12;
        if (ampm.toUpperCase() === 'AM' && hours === 12) hours = 0;
      }
      
      const date = new Date();
      date.setHours(hours, minutes, seconds, 0);
      
      if (arrivalTimeStr.toLowerCase().includes('tomorrow')) {
        date.setDate(date.getDate() + 1);
      }
      
      return date.getTime();
    }
    
    function parseSentToDate(sentTimeStr) {
      if (!sentTimeStr) return null;
      
      const timeMatch = sentTimeStr.match(/(\d{1,2}):(\d{2}):(\d{2})\s*(AM|PM)?/i);
      if (!timeMatch) return null;
      
      let hours = parseInt(timeMatch[1]);
      const minutes = parseInt(timeMatch[2]);
      const seconds = parseInt(timeMatch[3]);
      const ampm = timeMatch[4];
      
      if (ampm) {
        if (ampm.toUpperCase() === 'PM' && hours !== 12) hours += 12;
        if (ampm.toUpperCase() === 'AM' && hours === 12) hours = 0;
      }
      
      const date = new Date();
      
      if (sentTimeStr.toLowerCase().includes('yesterday')) {
        date.setDate(date.getDate() - 1);
      } else if (sentTimeStr.toLowerCase().includes('tomorrow')) {
        date.setDate(date.getDate() + 1);
      }
      
      date.setHours(hours, minutes, seconds, 0);
      
      return date.getTime();
    }
    
    let sortDirection = {};
    
    function sortTable(column) {
      sortDirection[column] = !sortDirection[column];
      const dir = sortDirection[column] ? 1 : -1;
      
      parsedData.sort((a, b) => {
        switch (column) {
          case 'origin':
            return dir * a.origin.name.localeCompare(b.origin.name);
          case 'target':
            return dir * a.target.name.localeCompare(b.target.name);
          case 'arrival':
            const arrA = parseArrivalToDate(a.arrivalTime) || 0;
            const arrB = parseArrivalToDate(b.arrivalTime) || 0;
            return dir * (arrA - arrB);
          case 'sent':
            const sentA = parseSentToDate(a.sentTime) || 0;
            const sentB = parseSentToDate(b.sentTime) || 0;
            return dir * (sentA - sentB);
          case 'remaining':
            return dir * (timeToSeconds(a.timeRemaining) - timeToSeconds(b.timeRemaining));
          case 'progress':
            return dir * (a.percentComplete - b.percentComplete);
          case 'distance':
            return dir * ((a.distance || 0) - (b.distance || 0));
          case 'unit':
            const unitA = a.unitType?.unit?.name || '';
            const unitB = b.unitType?.unit?.name || '';
            return dir * unitA.localeCompare(unitB);
          default:
            return 0;
        }
      });
      
      renderTable(parsedData);
    }
    
    function showToast(message) {
      // Remove existing toast if any
      const existingToast = document.querySelector('.toast');
      if (existingToast) existingToast.remove();
      
      const toast = document.createElement('div');
      toast.className = 'toast';
      toast.textContent = message;
      document.body.appendChild(toast);
      
      // Trigger animation
      setTimeout(() => toast.classList.add('show'), 10);
      
      // Remove after 3 seconds
      setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => toast.remove(), 300);
      }, 3000);
    }
  </script>
</body>
</html>
